Package compiler;


Helpers

	sp = ' ';												//space
  	lf = 0x000a; 											//line feed
  	cr = 0x000d;											//carriage return
  	ff = 0x000c;											//form feed
  	ht = 0x0009; 											//horizontal tab
	
	all = [0 .. 0xffff];
	letter = [['a'..'z'] + ['A'..'Z']];
	digit = ['0'..'9'];
	hex_digit = (digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f');
	hex_num = 'x' hex_digit hex_digit;
	


	escape = '\' ('n' | 't' | 'r' | '0' | '\' | ''' | '"' | hex_num);
	
	lterminator = (lf | cr | cr lf);
	
	comment = ([all - [lf + [cr + '$']]] [all - [lf + cr]]* lterminator?);
	line_comment = '$' ( comment | lterminator?);
	
	white_space = (sp | ht | ff | lterminator)*;
	    
	a = [all - '$'];
	middle = ('$'? a)* ;									// a* ('$' a a*)*
	multiline_comment =  '$' '$' middle '$' '$' ;


Tokens
	
	and = 'and';									//keys
	char = 'char';
	divide = 'div';
	do = 'do';
	else = 'else';
	fun = 'fun';
	if = 'if';
	integer = 'int';
	mod = 'mod';
	not = 'not';
	nothing = 'nothing';
	or = 'or';
	ref = 'ref';
	return = 'return';
	then = 'then';
	var = 'var';
	while = 'while';	
	
	id = letter (letter | digit | '_')*;			//Identifiers
	
	number = digit+;        						//Integer Numbers
	
	conchar = ''' (all | escape) ''';				//Constant Characters
	
	string = '"' ([all - '"'] | '\"')* '"';
  
	plus = '+';										//Symbolic operators
	minus = '-';
	mult = '*';
	div = '/';
	nequal = '#';
	equal = '=';
	less = '<';
	greater = '>';
	lesseq = '<=';
	greatereq = '>=';
	
	left_par = '(';									//Separators 
	right_par = ')';
	left_bracket = '[';
	right_bracket = ']';
	left_brace = '{';
	right_brace = '}';
	comma = ',';
	semicolon = ';';
	colon = ':';
	arrow = '<-';

	multiline_comment = multiline_comment;
	line_comment = line_comment;
	white_space = white_space;




Ignored Tokens
	
	white_space,
	line_comment,
	multiline_comment;	
	
  
Productions


	program = func_def;


	func_def = header local_def* block ;


	header = fun id left_par helper? right_par colon ret_type;

	helper = fpar_def helper0* ;
	helper0 = semicolon fpar_def ;


	fpar_def = ref? id helper1* colon fpar_type;
	helper1 = comma id ;


	data_type = {int} integer | {char} char ;
	
	type = data_type helper2* ;
	helper2 = left_bracket number right_bracket ; 

	ret_type = {data} data_type | {none} nothing ; 
	
	fpar_type = data_type helper3? helper4* ;
	helper3 = left_bracket right_bracket ;
	helper4 = left_bracket number right_bracket ;

	local_def = {funcdef} func_def | {funcdecl} func_decl | {vardef} var_def ;

	var_def = var id helper1* colon type semicolon ;

	func_decl = header semicolon ;


	block = left_brace stmt* right_brace ;


/////////////////// STMTS ///////////////////////

	stmt = {part} partstmt
			| {if} ifstmt
			| {while} whilestmt
			;

	partstmt = {none} semicolon
			| {assignment} l_value arrow expr semicolon
			| {block} block 
			| {funcall} func_call semicolon
			| {return} return expr? semicolon
			;
	
	ifstmt =  {noelse} if cond then stmt
			| {else} if cond then withelse else stmt
			; 

	withelse = if cond then [left]:withelse else [right]:withelse
			| {while} while cond do withelse
			| {partstmt} partstmt
			;
			
	whilestmt = while cond do stmt ;

/////////////////////////////////////////////////////////////////////























	
	
	
	
	
	
////////// EXRPESSIONS ///////////

	expr {-> expr} = 
			
			{plus} expr plus term 				{-> New expr.plus(expr.expr, term.expr)}
		|	{minus} expr minus term 			{-> New expr.minus(expr.expr, term.expr)}
		|	{term} term 						{-> term.expr} 
		;


	term {-> expr} =
	
			{mult} term mult factor				{-> New expr.mult(term.expr, factor.expr)}
		|	{div} term divide factor			{-> New expr.div(term.expr, factor.expr)}
		|	{mod} term mod factor				{-> New expr.mod(term.expr, factor.expr)}
		|	{factor} factor						{-> factor.expr}
		;

	
	factor {-> expr} =
			
			{pos} plus factor							{-> New expr.pos(factor.expr)}
		|	{neg} minus factor							{-> New expr.neg(factor.expr)}
		
		|	{num} number								{-> New expr.num(number)}
		|	{conchar} conchar							{-> New expr.conchar(conchar)}
		
		|	{lvalue} l_value							{-> l_value.expr}
		|	{fun_call} func_call						{-> fun_call.expr}
			
		|	{par} left_par expr right_par				{-> expr.expr}
		;
	
 
	l_value {-> expr} = 
		
			{id} id													{-> expr.id(id)} 
		|	{str} string	 										{-> expr.str(string)}
		|	{expr} l_value left_bracket expr right_bracket			{-> New expr.array(l_value.expr, expr.expr)}
		;

	
	func_call {-> expr} = id left_par expr_list? right_par 			{-> expr.fun_call(id, [expr_list.expr])} ;
	
	expr_list {-> expr*} = expr expr_list_tail* 					{-> [expr, expr_list_tail]} ;
	expr_list_tail {-> expr} = comma expr 							{-> expr} ;
	
	
////////// CONDITIONS ///////////

	cond {-> cond} = 
	
			{not} not cond										{-> cond.not(cond.cond)}		
		|	{condexit} condterm									{-> condterm.cond}
		;
		
	condterm {-> cond} = 
	
			{and} condterm and condrest							{-> cond.and(condterm.cond, condrest.cond)}
		|	{or} condterm or condrest							{-> cond.or(condterm.cond, condrest.cond)}
		|	{exit} condrest										{-> condrest.cond}
		;
		
	condrest {-> cond} = 
			
			{equal} [left]:expr equal [right]:expr				{-> cond.equal(left.expr, right.expr)}
		|	{nequal} [left]:expr nequal [right]:expr			{-> cond.nequal(left.expr, right.expr)}
		|	{less} [left]:expr less [right]:expr				{-> cond.less(left.expr, right.expr)}
		|	{greater} [left]:expr greater [right]:expr			{-> cond.greater(left.expr, right.expr)}
		|	{lesseq} [left]:expr lesseq [right]:expr			{-> cond.lesseq(left.expr, right.expr)}
		|	{greatereq} [left]:expr greatereq [right]:expr		{-> cond.greatereq(left.expr, right.expr)}
			
		|	{nest} left_par cond right_par						{-> cond.cond}
		;














Abstract Syntax Tree







////////// EXRPESSIONS ///////////

expr = 
		{plus} [left]:expr [right]:expr
	|	{minus} [left]:expr [right]:expr
	|	{mult} [left]:expr [right]:expr
	|	{div} [left]:expr [right]:expr
	|	{mod} [left]:expr [right]:expr
	
 	|	{pos} expr
	|	{neg} expr
	
	|	{conchar} conchar
 	|	{num} number
	
	|	{id} id
	|	{str} string
	|	{array} [left]:expr [right]:expr
	
	|	{fun_call} id expr*
	
	;
     
 ////////// CONDITIONS ///////////
 
 cond =
 		{not} cond
 	|	{and} [left]:cond [right]:cond
 	|	{or} [left]:cond [right]:cond
	
	|	{equal} [left]:expr [right]:expr	
 	|	{nequal} [left]:expr [right]:expr
 	|	{less} [left]:expr [right]:expr
 	|	{greater} [left]:expr [right]:expr
	|	{lesseq} [left]:expr [right]:expr
	|	{greatereq} [left]:expr [right]:expr
   




















