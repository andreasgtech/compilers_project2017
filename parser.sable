Package compiler;


Helpers

	sp = ' ';												//space
  	lf = 0x000a; 											//line feed
  	cr = 0x000d;											//carriage return
  	ff = 0x000c;											//form feed
  	ht = 0x0009; 											//horizontal tab
	
	all = [0 .. 0xffff];
	letter = [['a'..'z'] + ['A'..'Z']];
	digit = ['0'..'9'];
	hex_digit = (digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f');
	hex_num = 'x' hex_digit hex_digit;
	


	escape = '\' ('n' | 't' | 'r' | '\' | ''' | '"' | hex_num);

  lterminator = (lf | cr | cr lf);

  comment = ([all - [lf + [cr + '$']]] [all - [lf + cr]]* lterminator?);
  line_comment = '$' ( comment | lterminator?);

  white_space = (sp | ht | ff | lterminator)*;
    
	a = [all - '$'];
	middle = ('$'? a)* ;									// a* ('$' a a*)*
	multiline_comment =  '$' '$' middle '$' '$' ;


Tokens
	
	and = 'and';									//keys
	char = 'char';
	divide = 'div';
	do = 'do';
	else = 'else';
	fun = 'fun';
	if = 'if';
	integer = 'int';
	mod = 'mod';
	not = 'not';
	nothing = 'nothing';
	or = 'or';
	ref = 'ref';
	return = 'return';
	then = 'then';
	var = 'var';
	while = 'while';	
	
	id = letter (letter | digit | '_')*;			//Identifiers
	
	number = digit+;        						//Integer Numbers
	
	conchars = ''' (all | escape) ''';				//Constant Characters
	
	strings = '"' ([all - '"'] | '\"')* '"';
  
	plus = '+';										//Symbolic operators
	minus = '-';
	mult = '*';
	div = '/';
	nequal = '#';
	equal = '=';
	less = '<';
	greater = '>';
	lesseq = '<=';
	greatereq = '>=';
	
	left_par = '(';									//Separators 
	right_par = ')';
	left_bracket = '[';
	right_bracket = ']';
	left_brace = '{';
	right_brace = '}';
	comma = ',';
	semicolon = ';';
	colon = ':';
	arrow = '<-';

	multiline_comment = multiline_comment;
	line_comment = line_comment;
	white_space = white_space;




Ignored Tokens
	
	white_space,
	line_comment,
	multiline_comment;	
	
  
Productions


	program = {program} func_def;


	func_def = {func_def} (header⟩ (⟨local_def⟩)∗ ⟨block⟩;

	header = {header} fun id [left]:left_par (⟨fpar_def⟩ (semicolon ⟨fpar_def⟩)∗)? [right]:right_par colon ⟨ret_type⟩;


	fpar_def = {fparameters} ref? [left]:⟨id⟩ (comma ⟨[right]:(id)⟩)∗ colon ⟨fpar_type⟩;

	data_type = {intype} integer | {chartype} char ;

	type = {type} ⟨data-type⟩ (left_bracket number right_bracket)∗ ;

	ret_type = {retdata} ⟨data_type⟩ | {retnone} nothing ; 
	
	fpar_type = {fparam_type} ⟨data_type⟩ ([left1]:left_bracket [right1]:right_bracket)? ([left2]:left_bracket number [right2]:right_bracket)∗ ;


	local_def = {locfuncdef} ⟨func_def⟩ | {locfuncdecl} ⟨func_decl⟩ | {locvardef} ⟨var_def⟩ ;

	var_def = {vardef} var [left]:id (comma [right]:id)∗ colon ⟨type⟩ semicolon ;

	func_decl = {func_decl} ⟨header⟩ semicolon ;


	block = {block} left_brace (⟨stmt⟩)∗ right_brace ;

/////////////////// STMTS ///////////////////////

	stmt = {partstmt} partstmt 
		| {ifstmt} ifstmt;

	partstmt = {none} semicolon
			| {assignment} ⟨l_value⟩ arrow ⟨expr⟩ semicolon
			| {anblock} ⟨block⟩ 
			| {funcall} ⟨func_call⟩ semicolon
			| while ⟨cond⟩ do ⟨stmt⟩
			| return ⟨expr⟩? semicolon
			;
			
	ifstmt = {ifcase} ifcase;

	ifcase = {nested} if (cond) then (ifstmt)
			| {ifexit} if (cond) then (partstmt)
			| {ifelse} if (cond) then (withelse) else (stmt)
			; 

	withelse = {withelse} if (cond) then ([left]:withelse) else ([right]:withelse)
			| {ifterminal} partstmt
			;

/////////////////////////////////////////////////////////////////////


/////////////////// STMTS NEW ///////////////////////

	stmt = {partstmt} partstmt 
		| {ifstmt} ifstmt;
		| {whilestmt} whilestmt;

	partstmt = {none} semicolon
			| {assignment} ⟨l_value⟩ arrow ⟨expr⟩ semicolon
			| {anblock} ⟨block⟩ 
			| {funcall} ⟨func_call⟩ semicolon
			| return ⟨expr⟩? semicolon
			;
	whilestmt = {while} while ⟨cond⟩ do ⟨stmt⟩ ;
	
	ifstmt = {ifnested} if (cond) then (ifstmt)
			| {exitnest} if (cond) then (partstmt)
			| {exitnest_while} if (cond) then (whilestmt)
			
			| {ifelse} if (cond) then (withelse) else (stmt)
			; 

	withelse = {withelse} if (cond) then ([left]:withelse) else ([right]:withelse)
			| {withelse_while} withelse_while
			| {terminal} (partstmt)
			;
			
	withelse_while = {ww_nested} while (cond) do (withelse_while)
			| {wwif_nested} while (cond) do (withelse)
			| {exitwhile} (partstmt)
			;
	
	



/////////////////////////////////////////////////////////////////////



	l_value = {lval_id} id 
			| {lval_str} string 
			| {lval_expr} ⟨l_value⟩ left_bracket ⟨expr⟩ right_bracket
			;

	
	func_call = {funcall} id left_par (⟨[left]:expr⟩ (comma ⟨[right]:expr⟩)∗)? right_par
	
	
⟨expr⟩ ::= ⟨int-const⟩ | ⟨char-const⟩ | ⟨l-value⟩ | ⟨func-call⟩ | “(” ⟨expr⟩ “)”
| ( “+” | “-” ) ⟨expr⟩ | ⟨expr⟩ ( “+” | “-” | “ * ” | “div” | “mod” ) ⟨expr⟩
⟨cond⟩ ::= “(” ⟨cond⟩ “)” | “not” ⟨cond⟩ | ⟨cond⟩ ( “and” | “or” ) ⟨cond⟩
| ⟨expr⟩ ( “=” | “#” | “<” | “>” | “<=” | “>=” ) ⟨expr⟩





























