Package compiler;


Helpers

	sp = ' ';								//space
  	lf = 0x000a; 								//line feed
  	cr = 0x000d;								//carriage return
  	ff = 0x000c;								//form feed
  	ht = 0x0009; 								//horizontal tab
	
	all = [0 .. 0xffff];
	letter = [['a'..'z'] + ['A'..'Z']];
	digit = ['0'..'9'];
	hex_digit = (digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f');
	hex_num = 'x' hex_digit hex_digit;
	


	escape = '\' ('n' | 't' | 'r' | '\' | ''' | '"' | hex_num);

  lterminator = (lf | cr | cr lf);

  comment = ([all - [lf + [cr + '$']]] [all - [lf + cr]]* lterminator?);
  line_comment = '$' ( comment | lterminator?);

  white_space = (sp | ht | ff | lterminator)*;
    
	a = [all - '$'];
	middle = ('$'? a)* ;							// a* ('$' a a*)*
	multiline_comment =  '$' '$' middle '$' '$' ;


Tokens
	
	and = 'and';								//keys
	char = 'char';
	divide = 'div';
	do = 'do';
	else = 'else';
	fun = 'fun';
	if = 'if';
	integer = 'int';
	mod = 'mod';
	not = 'not';
	nothing = 'nothing';
	or = 'or';
	ref = 'ref';
	return = 'return';
	then = 'then';
	var = 'var';
	while = 'while';	
	
	id = letter (letter | digit | '_')*;					//Identifiers
	
	number = digit+;        						//Integer Numbers
	
	conchar = ''' (all | escape) ''';					//Constant Characters
	
	string = '"' ([all - '"'] | '\"')* '"';
  
	plus = '+';								//Symbolic operators
	minus = '-';
	mult = '*';
	div = '/';
	nequal = '#';
	equal = '=';
	less = '<';
	greater = '>';
	lesseq = '<=';
	greatereq = '>=';
	
	left_par = '(';								//Separators 
	right_par = ')';
	left_bracket = '[';
	right_bracket = ']';
	left_brace = '{';
	right_brace = '}';
	comma = ',';
	semicolon = ';';
	colon = ':';
	arrow = '<-';

	multiline_comment = multiline_comment;
	line_comment = line_comment;
	white_space = white_space;




Ignored Tokens
	
	white_space,
	line_comment,
	multiline_comment;	
	
  
Productions


	program = {program} func_def;


	func_def = {func_def} header local_def* block ;


	header = {header} fun id left_par helper? right_par colon ret_type;

	helper = {helper} fpar_def helper0* ;
	helper0 = {helper0} semicolon fpar_def ;


	fpar_def = {fparameters} ref? id helper1* colon fpar_type;
	helper1 = {fhelper1} comma id ;


	data_type = {intype} integer | {chartype} char ;
	
	type = {type} data_type helper2* ;
	helper2 = {helper2} left_bracket number right_bracket ; 

	ret_type = {retdata} data_type | {retnone} nothing ; 
	
	fpar_type = {fparam_type} data_type helper3? helper4* ;
	helper3 = {helper3} left_bracket right_bracket ;
	helper4 = {helper4} left_bracket number right_bracket ;

	local_def = {locfuncdef} func_def | {locfuncdecl} func_decl | {locvardef} var_def ;

	var_def = {vardef} var id helper1* colon type semicolon ;

	func_decl = {func_decl} header semicolon ;


	block = {block} left_brace stmt* right_brace ;


/////////////////// STMTS ///////////////////////

	stmt = {partstmt} partstmt 
			| {ifstmt} ifstmt
			| {whilestmt} whilestmt
			;

	partstmt = {none} semicolon
			| {assignment} l_value arrow expr semicolon
			| {anblock} block 
			| {funcall} func_call semicolon
			| return expr? semicolon
			;
	
	ifstmt =  {ifnoelse} if cond then stmt
			| {ifelse} if cond then withelse else stmt
			; 

	withelse = {withelse} if cond then [left]:withelse else [right]:withelse
			| {withelse_while} while cond do withelse
			| {terminal} partstmt
			;
			
	whilestmt = {while} while cond do stmt ;

/////////////////////////////////////////////////////////////////////



	l_value = {lval_id} id 
			| {lval_str} string 
			| {lval_expr} l_value left_bracket expr right_bracket
			;

	
	func_call = {funcall} id left_par helper6? right_par ;
	
	helper5 = {helper5} comma expr ;
	helper6 = {helper6} expr helper5* ;
	
////////// EXRPESSIONS ///////////

	expr = {plus} expr plus term
			| {minus} expr minus term
			| {term} term
			;


	term = {mult} term mult factor
		| {div} term div factor
		| {mod} term mod factor
		| {factor} factor
		;

	
	factor =  {pos} plus factor
		| {neg} minus factor
		| {lvalue} l_value
		| {fun_call} func_call
		| {num} number
		| {conchar} conchar
		
		| {par} left_par expr right_par
		;
		
		

////////// CONDITIONS ///////////

	cond = {not} not cond
		| {condexit} condterm
		;
		
	condterm = {and} condterm and condrest
		| {or} condterm or condrest
		| {condtermexit} condrest
		;
		
	condrest = {equal} [left]:expr equal [right]:expr
		| {nequal} [left]:expr nequal [right]:expr
		| {less} [left]:expr less [right]:expr
		| {greater} [left]:expr greater [right]:expr
		| {lesseq} [left]:expr lesseq [right]:expr
		| {greatereq} [left]:expr greatereq [right]:expr
		
		| {nest} left_par cond right_par
		;


























